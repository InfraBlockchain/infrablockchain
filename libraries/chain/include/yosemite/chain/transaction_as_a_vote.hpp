/**
 *  @file transaction_as_a_vote.hpp
 *  @brief YOSEMITE Transaction-as-a-vote Data Structure
 *  @author bezalel@yosemitex.com
 *  @copyright defined in LICENSE.txt
 */
#pragma once

#include <map>
#include <vector>
#include <eosio/chain/name.hpp>
#include <yosemite/chain/exceptions.hpp>
#include <fc/reflect/reflect.hpp>

#define YOSEMITE_TRANSACTION_VOTE_ACCOUNT_TX_EXTENSION_FIELD 1001

namespace yosemite_core {

    using std::map;
    using std::vector;

    /**
     *
     * YOSEMITE Proof-of-Transaction(PoT) and Transaction-as-a-Vote (TaaV)
     *
     * Proof-of-Transaction (PoT) incentivizes the application
     * service providers directly contributing to the blockchain ecosystem by generating actual
     * blockchain transactions, quantitatively measured by Transaction-as-a-Vote (TaaV).
     *
     * The key idea that makes Proof-of-Transaction a novel blockchain consensus mechanism is the
     * concept of Transaction-as-a-Vote (TaaV). Transactions generated by the client side of the
     * blockchain applications can optionally include a vote for a block producer candidate who can
     * potentially participate or is already participating in the blockchain consensus process. In
     * blockchain transaction messages which would incur some transaction fee, there is an optional
     * "transaction vote" field where a blockchain account address can be specified as a vote. That
     * means the entity generating the transaction on blockchain wants the blockchain core node
     * having the voted address to be a block producer.
     *
     *
     *
     * ### Transaction-as-a-Vote message protocol
     *
     * struct transaction_header {
     *    time_point_sec         expiration;   ///< the time at which a transaction expires
     *    uint16_t               ref_block_num       = 0U; ///< specifies a block num in the last 2^16 blocks.
     *    uint32_t               ref_block_prefix    = 0UL; ///< specifies the lower 32 bits of the blockid at get_ref_blocknum
     *    fc::unsigned_int       max_net_usage_words = 0UL; /// upper limit on total network bandwidth (in 8 byte words) billed for this transaction
     *    uint8_t                max_cpu_usage_ms    = 0; /// upper limit on the total CPU time billed for this transaction
     *    fc::unsigned_int       delay_sec           = 0UL; /// number of seconds to delay this transaction for during which it may be canceled.
     * };
     *
     * typedef vector<std::pair<uint16_t,vector<char>>> extensions_type;
     *
     * struct transaction : public transaction_header {
     *    vector<action>         context_free_actions;
     *    vector<action>         actions;
     *    extensions_type        transaction_extensions;
     * }
     *
     * YOSEMITE Transaction-as-a-Vote protocol uses "transaction_extensions" field of EOS transaction binary data format.
     * The transaction-extension field code for YOSEMITE TaaV is 1001,
     * and the field value should be encoded as the binary representation of 64bit base-32 encoding for blockchain account name of transaction-vote target(candidate)
     *
     * Example of json representation blockchain transaction with YOSEMITE TaaV
     * {
     *   "expiration": "2018-08-16T06:17:11",
     *   "ref_block_num": 30369,
     *   "ref_block_prefix": 1005358512,
     *   "max_net_usage_words": 0,
     *   "max_cpu_usage_ms": 0,
     *   "delay_sec": 0,
     *   "context_free_actions": [],
     *   "actions": [{
     *       "account": "yx.ntoken",
     *       "name": "transfer",
     *       "authorization": [{
     *           "actor": "useraccount3",
     *           "permission": "active"
     *         }
     *       ],
     *       "data": "30f2d414217315d620f2d414217315d600e1f5050000000004444b5257000000046d656d6f"
     *     }
     *   ],
     *   "transaction_extensions": [[
     *       1001,
     *       "00c00257219de8ad"
     *     ]
     *   ],
     *   "signatures": [
     *     "SIG_K1_K24Pe1TVtdCzY2s4NvfvPd28NL1jHoFUEsugxPCXqonoSJDZ4XD9S7CMBP8WyTbhkBFweWT9GLBDDJgQCv9qSaL8SLbR2s"
     *   ],
     *   "context_free_data": []
     * }
     *
     */

    using transaction_vote_candidate_name_type = eosio::chain::name;
    using transaction_vote_amount_type = uint32_t;

    struct transaction_vote {

        explicit transaction_vote(transaction_vote_candidate_name_type c, transaction_vote_amount_type v) : candidate(c), vote_amount(v) {}

        transaction_vote_candidate_name_type candidate; // eosio::chain::name
        transaction_vote_amount_type vote_amount;

        bool has_vote() {
            return !candidate.empty() && vote_amount != 0;
        }
    };

    struct transaction_votes_in_block {

        // ordered map
        map<transaction_vote_candidate_name_type, transaction_vote_amount_type> tx_votes;

        void add_transaction_vote(const transaction_vote& tx_vote) {

            auto vote_it = tx_votes.find(tx_vote.candidate);
            if (vote_it == tx_votes.end()) {
                tx_votes[tx_vote.candidate] = tx_vote.vote_amount;
            } else {
                auto current = tx_votes[tx_vote.candidate];
                auto new_val = current + tx_vote.vote_amount;
                EOS_ASSERT( new_val > current, eosio::chain::arithmetic_exception, "overflow of transaction vote amount");
                tx_votes[tx_vote.candidate] =  new_val;
            }
        }

        vector<transaction_vote> get_tx_vote_list() {

            vector<transaction_vote> tx_vote_list;
            tx_vote_list.reserve( tx_votes.size() );

            // tx_votes : ordered map
            for (auto i = tx_votes.begin(); i != tx_votes.end(); i++) {
                tx_vote_list.push_back( transaction_vote(i->first, i->second) );
            }

            return tx_vote_list;
        }

        bool has_transaction_votes() {
            return tx_votes.size() > 0;
        }
    };

}

FC_REFLECT(yosemite_core::transaction_vote, (candidate)(vote_amount))
FC_REFLECT(yosemite_core::transaction_votes_in_block, (tx_votes))