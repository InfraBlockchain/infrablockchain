/**
 *  @file transaction_as_a_vote.hpp
 *  @brief YOSEMITE Transaction-as-a-vote Data Structure
 *  @author bezalel@yosemitex.com
 *  @copyright defined in LICENSE.txt
 */
#pragma once

#include <map>
#include <vector>
#include <eosio/chain/name.hpp>
#include <eosio/chain/exceptions.hpp>
#include <fc/reflect/reflect.hpp>

#define YOSEMITE_TRANSACTION_VOTE_ACCOUNT_TX_EXTENSION_FIELD 1001

namespace yosemite_core {

    using std::map;
    using std::vector;

    /**
     *
     * YOSEMITE Proof-of-Transaction(PoT) and Transaction-as-a-Vote (TaaV)
     *
     * Proof-of-Transaction (PoT) incentivizes the application
     * service providers directly contributing to the blockchain ecosystem by generating actual
     * blockchain transactions, quantitatively measured by Transaction-as-a-Vote (TaaV).
     *
     * The key idea that makes Proof-of-Transaction a novel blockchain consensus mechanism is the
     * concept of Transaction-as-a-Vote (TaaV). Transactions generated by the client side of the
     * blockchain applications can optionally include a vote for a block producer candidate who can
     * potentially participate or is already participating in the blockchain consensus process. In
     * blockchain transaction messages which would incur some transaction fee, there is an optional
     * "transaction vote" field where a blockchain account address can be specified as a vote. That
     * means the entity generating the transaction on blockchain wants the blockchain core node
     * having the voted address to be a block producer.
     *
     */

    using transaction_vote_candidate_name_type = eosio::chain::name;
    using transaction_vote_amount_type = uint32_t;

    struct transaction_vote {

        explicit transaction_vote(transaction_vote_candidate_name_type c, transaction_vote_amount_type v) : candidate(c), vote_amount(v) {}

        transaction_vote_candidate_name_type candidate; // eosio::chain::name
        transaction_vote_amount_type vote_amount;

        bool has_vote() {
            return !candidate.empty() && vote_amount != 0;
        }
    };

    struct transaction_votes_in_block {

        // ordered map
        map<transaction_vote_candidate_name_type, transaction_vote_amount_type> tx_votes;

        void add_transaction_vote(const transaction_vote& tx_vote) {

            auto vote_it = tx_votes.find(tx_vote.candidate);
            if (vote_it == tx_votes.end()) {
                tx_votes[tx_vote.candidate] = tx_vote.vote_amount;
            } else {
                auto current = tx_votes[tx_vote.candidate];
                auto new_val = current + tx_vote.vote_amount;
                EOS_ASSERT( new_val > current, eosio::chain::arithmetic_exception, "overflow of transaction vote amount");
                tx_votes[tx_vote.candidate] =  new_val;
            }
        }

        vector<transaction_vote> get_tx_vote_list() {

            vector<transaction_vote> tx_vote_list;
            tx_vote_list.reserve( tx_votes.size() );

            // tx_votes : ordered map
            for (auto i = tx_votes.begin(); i != tx_votes.end(); i++) {
                tx_vote_list.push_back( transaction_vote(i->first, i->second) );
            }

            return tx_vote_list;
        }
    };

}

FC_REFLECT(yosemite_core::transaction_vote, (candidate)(vote_amount))
FC_REFLECT(yosemite_core::transaction_votes_in_block, (tx_votes))